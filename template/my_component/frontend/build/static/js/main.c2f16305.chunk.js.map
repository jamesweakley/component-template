{"version":3,"sources":["StreamlitAsyncWrapper.tsx","index.tsx"],"names":["withStreamlitConnection","props","useEffect","Streamlit","setFrameHeight","useState","isFocused","setFocused","isLoading","setLoading","queryResults","setQueryResults","theme","style","borderStyling","primaryColor","border","outline","args","console","log","parent","postMessage","JSON","parse","doAction","action","a","iframe","document","createElement","searchUrl","window","location","search","streamlitUrl","decodeURIComponent","replace","stringify","src","display","iframeElement","body","appendChild","Promise","resolve","contentWindow","addEventListener","e","data","message","undefined","isStreamlitMessage","removeChild","onClicked","onClick","disabled","onFocus","onBlur","ReactDOM","render","StrictMode","getElementById"],"mappings":"iQAqIeA,eA/Ge,SAACC,GAC7BC,qBAAU,WACRC,IAAUC,oBAEZ,MAAgCC,oBAAkB,GAAlD,mBAAOC,EAAP,KAAkBC,EAAlB,KACA,EAAgCF,oBAAkB,GAAlD,mBAAOG,EAAP,KAAkBC,EAAlB,KAGA,EAAwCJ,qBAAxC,mBAAOK,EAAP,KAAqBC,EAArB,KAEQC,EAAUX,EAAVW,MACFC,EAA6B,GAInC,GAAID,EAAO,CAGT,IAAME,EAAa,oBACjBR,EAAYM,EAAMG,aAAe,QAEnCF,EAAMG,OAASF,EACfD,EAAMI,QAAUH,EAGdb,EAAMiB,KAAN,iBACFC,QAAQC,IAAI,yBAAyBnB,EAAMiB,KAAN,gBACrCG,OAAOC,YAAYC,KAAKC,MAAMvB,EAAMiB,KAAN,kBAGhC,IAAMO,EAAQ,uCAAC,WAAOC,GAAP,qBAAAC,EAAA,6DACTC,EAAaC,SAASC,cAAc,UAClCC,EAAUC,OAAOC,SAASC,OAC1BC,EAAaC,mBAAmBL,EAAUM,QAAQ,iBAAiB,KACzElB,QAAQC,IAAI,wBAAwBe,EAAa,WAAWZ,KAAKe,UAAUZ,IAC3EE,EAAOW,IAAMJ,EAAa,WAAWZ,KAAKe,UAAUZ,GACpDE,EAAOf,MAAM2B,QAAU,OACnBC,EAAgBZ,SAASa,KAAKC,YAAYf,GAPjC,kBAQN,IAAIgB,SAAQ,SAASC,GAC1BjB,EAAOkB,cAAcC,iBAAiB,WAAW,SAACC,GAChD,IACMC,EAAOD,EADDA,EAAEE,QAAU,UAAY,QAEpC/B,QAAQC,IAAI,OAAO6B,QACWE,IAA1BF,EAAKG,qBACPvB,SAASa,KAAKW,YAAYZ,GAC1BI,EAAQI,OAEV,OAjBS,2CAAD,sDAsBRK,EAAS,uCAAG,4BAAA3B,EAAA,6DAGhBR,QAAQC,IAAI,iBACZX,GAAW,GAJK,SAKSgB,EAAS,CAAC,MAAQ,aAL3B,OAKZf,EALY,OAMhBC,EAAgBD,GAChBD,GAAW,GAPK,2CAAH,qDA6Bf,OACE,8BACGD,GACC,4CAIAA,GACA,gDACmBe,KAAKe,UAAU5B,GAAc,8BAGlD,4BACEG,MAAOA,EACP0C,QAASD,EACTE,SAAUvD,EAAMuD,SAChBC,QA9BW,WACflD,GAAW,IA8BPmD,OA1BU,WACdnD,GAAW,KAoBT,kBC/GNoD,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFhC,SAASiC,eAAe,W","file":"static/js/main.c2f16305.chunk.js","sourcesContent":["import {\r\n  Streamlit,\r\n  Theme,\r\n  withStreamlitConnection,\r\n} from \"streamlit-component-lib\"\r\nimport React, { ReactNode, useEffect, useState } from \"react\"\r\n\r\ninterface StreamlitPropsState {\r\n  args: any;\r\n  /** The component's width. */\r\n  width: number;\r\n  /**\r\n   * True if the component should be disabled.\r\n   * All components get disabled while the app is being re-run,\r\n   * and become re-enabled when the re-run has finished.\r\n   */\r\n  disabled: boolean;\r\n  /** Theme definition dictionary passed from the main client.*/\r\n  theme?: Theme;\r\n}\r\ndeclare var parent: any;\r\n\r\nconst StreamlitAsyncWrapper = (props:StreamlitPropsState) => {\r\n  useEffect(() => {\r\n    Streamlit.setFrameHeight();\r\n  });\r\n  const [isFocused, setFocused] = useState<boolean>(false);\r\n  const [isLoading, setLoading] = useState<boolean>(false);\r\n  // Arguments that are passed to the plugin in Python are accessible\r\n  // via `this.props.args`\r\n  const [queryResults, setQueryResults] = useState<any>();\r\n\r\n  const { theme } = props\r\n  const style: React.CSSProperties = {}\r\n\r\n  // Maintain compatibility with older versions of Streamlit that don't send\r\n  // a theme object.\r\n  if (theme) {\r\n    // Use the theme object to style our button border. Alternatively, the\r\n    // theme style is defined in CSS vars.\r\n    const borderStyling = `1px solid ${\r\n      isFocused ? theme.primaryColor : \"gray\"\r\n    }`\r\n    style.border = borderStyling\r\n    style.outline = borderStyling\r\n  }\r\n\r\n  if (props.args[\"action_results\"]){\r\n    console.log('posting action results',props.args[\"action_results\"])\r\n    parent.postMessage(JSON.parse(props.args[\"action_results\"]))\r\n  }\r\n\r\n  const doAction=async (action:object):Promise<any> => {\r\n    var iframe:any = document.createElement('iframe');\r\n    const searchUrl=window.location.search;\r\n    const streamlitUrl=decodeURIComponent(searchUrl.replace('?streamlitUrl=',''));\r\n    console.log('opening component at ',streamlitUrl+'?action='+JSON.stringify(action));\r\n    iframe.src = streamlitUrl+'?action='+JSON.stringify(action);\r\n    iframe.style.display = 'none';\r\n    var iframeElement = document.body.appendChild(iframe);\r\n    return new Promise(function(resolve){\r\n      iframe.contentWindow.addEventListener('message', (e:any) => {\r\n        const key = e.message ? 'message' : 'data';\r\n        const data = e[key];\r\n        console.log('data',data);\r\n        if (data.isStreamlitMessage===undefined){\r\n          document.body.removeChild(iframeElement);\r\n          resolve(data);\r\n        }\r\n      },false);\r\n    });\r\n  }\r\n\r\n  /** Click handler for our \"Click Me!\" button. */\r\n  const onClicked = async (): Promise<void> => {\r\n    // Increment state.numClicks, and pass the new value back to\r\n    // Streamlit via `Streamlit.setComponentValue`.\r\n    console.log('running query');\r\n    setLoading(true);\r\n    var queryResults = await doAction({'query':'select 1'});\r\n    setQueryResults(queryResults);\r\n    setLoading(false);\r\n    /*this.setState(\r\n      prevState => ({ numClicks: prevState.numClicks + 1 }),\r\n      () => Streamlit.setComponentValue(this.state.numClicks)\r\n    )*/\r\n  }\r\n\r\n  /** Focus handler for our \"Click Me!\" button. */\r\n  const _onFocus = (): void => {\r\n    setFocused(true);\r\n  }\r\n\r\n  /** Blur handler for our \"Click Me!\" button. */\r\n  const _onBlur = (): void => {\r\n    setFocused(false);\r\n  }\r\n  \r\n\r\n  // Show a button and some text.\r\n  // When the button is clicked, we'll increment our \"numClicks\" state\r\n  // variable, and send its new value back to Streamlit, where it'll\r\n  // be available to the Python program.\r\n  return (\r\n    <span>\r\n      {isLoading &&\r\n        <div>\r\n          Loading...\r\n        </div>\r\n      }\r\n      {!isLoading &&\r\n        <div>\r\n          action results: {JSON.stringify(queryResults)}<hr/>\r\n        </div>\r\n      }\r\n      <button\r\n        style={style}\r\n        onClick={onClicked}\r\n        disabled={props.disabled}\r\n        onFocus={_onFocus}\r\n        onBlur={_onBlur}\r\n      >\r\n        Run query!\r\n      </button>\r\n    </span>\r\n  )\r\n}\r\n\r\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\r\n// connection between your component and the Streamlit app, and handles\r\n// passing arguments from Python -> Component.\r\n//\r\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\r\nexport default withStreamlitConnection(StreamlitAsyncWrapper)\r\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport StreamlitAsyncWrapper from \"./StreamlitAsyncWrapper\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <StreamlitAsyncWrapper />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}